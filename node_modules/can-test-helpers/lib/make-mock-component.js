var viewCallbacks = require('can-view-callbacks');
var nodeLists = require('can-view-nodelist');

var domData = require('can-util/dom/data/data');
var domMutate = require('can-util/dom/mutate/mutate');

var canReflect = require('can-reflect');

module.exports = function makeMockComponent(bindingsFunction, mapType) {
	return {
		extend: function(proto){

			viewCallbacks.tag(proto.tag, function(el, componentTagData){
				var viewModel;
				function makeViewModel(initialViewModelData) {
					var protoVM = proto.ViewModel || proto.viewModel;

					if(typeof protoVM === "function") {
						return viewModel = new protoVM(initialViewModelData);
					} else if(canReflect.isObservableLike(protoVM)) {
						canReflect.assignDeep(protoVM, initialViewModelData);
						return viewModel = protoVM;
					} else if(canReflect.isConstructorLike(mapType) && typeof mapType.extend === "function") {
						var VM = mapType.extend(proto.tag.tagName + "_MockVM", protoVM);
						return viewModel = new VM(initialViewModelData);
					} else {
						throw 'Cannot create a view model for the mock component';
					}
				}
				var teardownBindings;
				if(bindingsFunction) {
					teardownBindings = bindingsFunction(el, componentTagData, makeViewModel);
				} else { 
					viewModel = mapType ? new mapType() : {};
				}
				domData.set.call(el, "viewModel", viewModel);
				domData.set.call(el, "preventDataBindings", true);

				var template = proto.view || proto.template;

				if(template) {
					var shadowScope = componentTagData.scope.add(new componentTagData.scope.constructor.Refs())
						.add(viewModel, {
							viewModel: true
						});
					domData.set.call(el, "shadowScope", shadowScope);
					var nodeList = nodeLists.register([], function(){
						teardownBindings && teardownBindings();
					}, componentTagData.parentNodeList || true, false);
					var frag = template(shadowScope, componentTagData.options, nodeList);

					domMutate.appendChild.call(el, frag);
				}
			});
		}
	};
};
